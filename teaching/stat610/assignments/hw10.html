<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.8">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.17/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/combine/npm/katex@0.16.25/dist/katex.min.js,npm/katex@0.16.25/dist/contrib/auto-render.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.17/js/render-katex.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<h1 id="chp:lab-7-homework-10">Lab 7/Homework 10</h1>
<p>Due Wednesday, December 3, 11:59pm</p>
<p>A common model in epidemiology is a <a href="https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology">Susceptible-Infected-Recovered (SIR) model</a>.
These are usually written as deterministic, but a simple modification makes it into a Markov chain, which is slightly more realistic.</p>
<p>In this assignment, you will simulate from an SIR Markov chain.</p>
<p>As we discussed in class, to define a Markov chain we need to define the state space and the transition probabilities.
For our SIR model, the state space is going to be the set of triples \((S, I, R)\), such that \(S, I, R \in \{0, \ldots, N\}\), and \(S + I + R = N\).
The idea is that we have a total population of \(N\) individuals, with \(S\) of those being susceptible to the disease, \(I\) of those being currently infected, and \(R\) being recovered and no longer susceptible to the disease.</p>
<p>For the transition probabilities, from one time step to the next we can either move one individual from the susceptible compartment to the infected compartment (\((S, I, R) \rightarrow (S - 1, I + 1, R)\)) or we can move one individual from the infected compartment to the recovered compartment (\((S, I, R) \rightarrow (S, I - 1, R + 1)\)).
If \(S + I &gt; 0\), the probabilities are
\begin{align}
  P[(S, I, R) \rightarrow (S - 1, I + 1, R)] &amp;= \beta \frac{I}{N} S / C \label{eq:pi}\\
  P[(S, I, R) \rightarrow (S, I - 1, R + 1)] &amp;= \gamma I / C \label{eq:pr}\\
  C &amp;= \beta \frac{I}{N} S + \gamma I,
\end{align}
where \(\beta\) and \(\gamma\) are parameters of the model.
If \(S + I = 0\), the transition probability is:
\begin{align}
P[(S, I, R) \rightarrow (S, I, R)] = 1.\label{eq:pab}
\end{align}
All other transitions have probability 0.</p>
<p>The idea is that \(\gamma\) controls the recovery rate (large values of \(\gamma\) mean that individuals leave the “infected” compartment quickly), and \(\beta\) controls the infection rate.
The state \((0,0,N)\) is an “absorbing” state: once everyone has recovered, the chain stays at \((0,0,N)\) forever.</p>
<p>What you should do:</p>
<ol>
<li>Write a function that takes a current state (that is, a triple \((S, I, R)\)), values for the parameters \(\beta\) and \(\gamma\), and simulates one step in the Markov chain.</li>
</ol>
<pre><code class="language-r">## current_state should be a list with elements S, I, and R.  beta and
## gamma should be model parameters
take_one_step &lt;- function(current_state, beta, gamma) {

}
</code></pre>
<p>That is, your function will compute the probabilities in (\ref{eq:pi}-\ref{eq:pab}), and will return either \((S - 1, I + 1, R)\) or \((S, I - 1, R + 1)\) with the probabilities you computed.
2. Write a function that will simulate some fixed number of step (say, 1000), from the SIR Markov chain.
The function should take a starting state (for example, \((100, 0, 0)\)) and should record the state of the chain across all the steps.</p>
<pre><code class="language-r">## starting_state should be a list with elements S, I, and R.  beta
## and gamme should be model parameters. n_steps should be the number
## of steps to take. It will probably be easiest to deal with if the
## output is a list of vectors, one for S, one for I, and one for R.
simulate_sir &lt;- function(starting_state, beta, gamma, n_steps) {
	
}
</code></pre>
<ol start="3">
<li>Run your chain and either plot or print out some summary of how the chain evolved.</li>
<li>Your simulation takes fixed values of \(\beta\) and \(\gamma\).
Suppose you had data from a real epidemic and wanted to model the real epidemic using this SIR model.</li>
</ol>
<pre><code class="language-r">draw_params_from_prior &lt;- function() {
	beta &lt;- runif(0, 10)
	gamma &lt;- runif(0, 10)
	return(list(beta = beta, gamma = gamma))
}
## sir_path should be in whatever format the output of simulate_sir
## is. The output should be a vector of summary statistics.
summary_statistic &lt;- function(sir_path) {

}
</code></pre>
<h2 id="sec:submission-parameters">Submission parameters</h2>
<p>Submit two files:</p>
<ul>
<li>A pdf or html containing your plots and answers to the questions.</li>
<li>An Rmd or R file containing the code you used.</li>
</ul>
</div>
</body>
</html>
