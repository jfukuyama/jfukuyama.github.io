<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Stat 610 Lecture 7: Split/apply/combine</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Stat 610 Lecture 7: Split/apply/combine</h1>
</div>
<div id="avoiding-iteration-splitapplycombine" class="slide section level2">
<h1>Avoiding iteration, split/apply/combine</h1>
<p>Reading: R Cookbook, Chapter 6</p>
<p>Agenda for today:</p>
<ul class="incremental">
<li><p>Avoiding iteration in base R</p></li>
<li><p>Split/apply/combine</p></li>
</ul>
</div>
<div id="avoiding-iteration" class="slide section level2">
<h1>Avoiding iteration</h1>
<p>We’ve already seen a lot of examples of functions in R that are written so as to avoid iteration.</p>
<p>Built-in functions for making sequences or repeating elements, for example, we can say:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>x =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">11</span>, <span class="dt">by =</span> <span class="dv">2</span>)</span></code></pre></div>
<p>instead of</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>x =<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">6</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)) {</span>
<span id="cb2-3"><a href="#cb2-3"></a>    x[i] =<span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a>}</span></code></pre></div>
</div>
<div class="slide section level2">

<p>Most of the built-in functions are vectorized, so we can use</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>log_x =<span class="st"> </span><span class="kw">log</span>(x)</span></code></pre></div>
<p>instead of</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>log_x =<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)) {</span>
<span id="cb4-3"><a href="#cb4-3"></a>    log_x[i] =<span class="st"> </span><span class="kw">log</span>(x[i])</span>
<span id="cb4-4"><a href="#cb4-4"></a>}</span></code></pre></div>
</div>
<div class="slide section level2">

<p>Plus a whole bunch we haven’t seen yet, like <code>rowSums</code>, <code>colMeans</code>, <code>sweep</code>, <code>scale</code></p>
<p>However, not everything is vectorized, and you will often want to go beyond the built-in functions, and for that you use the <code>*apply</code> family of functions.</p>
</div>
<div id="applying-to-one-dimensional-structures" class="slide section level2">
<h1>Applying to one-dimensional structures</h1>
<p><code>lapply</code>, and <code>sapply</code> will apply a function to a one-dimensional structure.</p>
<p>The difference between them is how the output is formatted.</p>
<p>They have the same syntax: <code>lapply(X = x, FUN = fun, ...)</code>, <code>sapply(X = x, FUN = fun, ...)</code></p>
<ul class="incremental">
<li><p><code>x</code> is a vector or list that the function should be applied to</p></li>
<li><p><code>fun</code> is the function that should be applied to each element of the vector or the list</p></li>
<li><p>You can specify other arguments in the <code>...</code> portion. <code>fun</code> will be called with first argument equal to each element of <code>x</code>, and subsequent arguments anything you specify in the <code>...</code> portion.</p></li>
</ul>
<div class="incremental">
<p>Return values:</p>
<ul class="incremental">
<li><p><code>lapply</code> returns a list with length equal to the length of <code>x</code> containing the result of the function evaluation on the corresponding element of <code>x</code>.</p></li>
<li><p><code>sapply</code> tries to simplify the output to a vector or matrix. If each element of the output is of length 1 it returns a vector. If each element has the same length of two or more, it returns a matrix. Otherwise it returns a list like <code>lapply</code>.</p></li>
</ul>
</div>
</div>
<div class="slide section level2">

<p>Examples from the homework:</p>
<div class="incremental">
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">library</span>(readr)</span>
<span id="cb5-2"><a href="#cb5-2"></a>book_dir =<span class="st"> &quot;~/GitHub/stat-comp-fall-20/assignments/hw1/books&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>book_file_names =<span class="st"> </span><span class="kw">list.files</span>(book_dir, <span class="dt">full.names =</span> <span class="ot">TRUE</span>)</span>
<span id="cb5-4"><a href="#cb5-4"></a>books =<span class="st"> </span><span class="kw">lapply</span>(book_file_names, read_file)</span></code></pre></div>
<p>We need to do this because <code>read_file</code> doesn’t vectorize. Check what happens if you do <code>read_file(book_file_names)</code> (you’ll have to change <code>book_dir</code> to wherever you saved the books to).</p>
</div>
</div>
<div class="slide section level2">

<div class="incremental">
<p>Example using extra function arguments:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>get_num_characters =<span class="st"> </span><span class="cf">function</span>(file_name, honorific_regex) {</span>
<span id="cb6-2"><a href="#cb6-2"></a>    text =<span class="st"> </span><span class="kw">read_file</span>(file_name)</span>
<span id="cb6-3"><a href="#cb6-3"></a>    name_matches =<span class="st"> </span><span class="kw">regmatches</span>(text, <span class="kw">gregexpr</span>(honorific_regex, text))[[<span class="dv">1</span>]]</span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">return</span>(<span class="kw">length</span>(<span class="kw">unique</span>(name_matches)))</span>
<span id="cb6-5"><a href="#cb6-5"></a>}</span>
<span id="cb6-6"><a href="#cb6-6"></a>first_five_books =<span class="st"> </span><span class="kw">list.files</span>(book_dir, <span class="dt">full.names =</span> <span class="ot">TRUE</span>)[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">lapply</span>(first_five_books, get_num_characters, <span class="st">&quot;(((Mr|Ms|Mrs|Dr)</span><span class="ch">\\</span><span class="st">.?)|Miss) ([A-Z]([a-z]+|</span><span class="ch">\\</span><span class="st">.)[ ]+)+[A-Z][a-z]+&quot;</span>)</span></code></pre></div>
<pre><code>## [[1]]
## [1] 0
## 
## [[2]]
## [1] 7
## 
## [[3]]
## [1] 8
## 
## [[4]]
## [1] 40
## 
## [[5]]
## [1] 2</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">sapply</span>(first_five_books, get_num_characters, <span class="st">&quot;(((Mr|Ms|Mrs|Dr)</span><span class="ch">\\</span><span class="st">.?)|Miss) ([A-Z]([a-z]+|</span><span class="ch">\\</span><span class="st">.)[ ]+)+[A-Z][a-z]+&quot;</span>)</span></code></pre></div>
<pre><code>## /Users/jfukuyam/GitHub/stat-comp-fall-20/assignments/hw1/books/1289-0.txt 
##                                                                         0 
## /Users/jfukuyam/GitHub/stat-comp-fall-20/assignments/hw1/books/1400-0.txt 
##                                                                         7 
##  /Users/jfukuyam/GitHub/stat-comp-fall-20/assignments/hw1/books/564-0.txt 
##                                                                         8 
##  /Users/jfukuyam/GitHub/stat-comp-fall-20/assignments/hw1/books/580-0.txt 
##                                                                        40 
##  /Users/jfukuyam/GitHub/stat-comp-fall-20/assignments/hw1/books/653-0.txt 
##                                                                         2</code></pre>
</div>
</div>
<div id="applying-to-two-dimensional-structures" class="slide section level2">
<h1>Applying to two-dimensional structures</h1>
<p>Syntax: <code>apply(X = mat, MARGIN = dim, FUN = fun, ...)</code></p>
<ul class="incremental">
<li><p><code>mat</code>: The matrix or data frame you want to apply the function to.</p></li>
<li><p><code>dim</code>: Either 1 or 2: 1 means apply the function to each row in <code>mat</code>, 2 means apply the function to each column in <code>mat</code>. (1 and 2 are related to the way the dimensions are laid out: the first dimension in the matrix is the number of rows, the second is the number of columns.)</p></li>
<li><p><code>fun</code>: The function you want to apply to each row or to each column. It should take a vector as its first argument.</p></li>
<li><p><code>...</code>: Extra arguments to be passed to <code>fun</code>.</p></li>
</ul>
<p>As with <code>lapply</code> and <code>sapply</code>, <code>fun</code> will be called with each row or each column of <code>mat</code> as its first argument, along with any extra arguments specified after the function.</p>
</div>
<div class="slide section level2">

<p>Some simple examples:</p>
<div class="incremental">
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>X =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="op">-</span><span class="dv">5</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">size =</span> <span class="dv">20</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>), <span class="dt">nrow =</span> <span class="dv">4</span>, <span class="dt">ncol =</span> <span class="dv">5</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a>X</span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    3   -4    5   -1    1
## [2,]   -2    1   -3    4    3
## [3,]    1    5   -5    0   -1
## [4,]   -5   -4   -1    4   -1</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">apply</span>(X, <span class="dv">2</span>, min)</span></code></pre></div>
<pre><code>## [1] -5 -4 -5 -1 -1</code></pre>
</div>
</div>
<div class="slide section level2">

<div class="incremental">
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>log_X =<span class="st"> </span><span class="kw">log</span>(X)</span></code></pre></div>
<pre><code>## Warning in log(X): NaNs produced</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>log_X</span></code></pre></div>
<pre><code>##          [,1]     [,2]     [,3]     [,4]     [,5]
## [1,] 1.098612      NaN 1.609438      NaN 0.000000
## [2,]      NaN 0.000000      NaN 1.386294 1.098612
## [3,] 0.000000 1.609438      NaN     -Inf      NaN
## [4,]      NaN      NaN      NaN 1.386294      NaN</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">apply</span>(log_X, <span class="dv">1</span>, min, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 0.000000 0.000000     -Inf 1.386294</code></pre>
</div>
</div>
<div class="slide section level2">

<p>Be careful when using apply on rows of a data frame: apply assumes the argument you pass to the function is a vector, and will coerce the rows of the data frame to vectors to make it so.</p>
<div class="incremental">
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>steak_combinations =<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb20-2"><a href="#cb20-2"></a>    <span class="dt">temp =</span> <span class="kw">c</span>(<span class="dv">117</span>, <span class="dv">120</span>, <span class="dv">135</span>, <span class="dv">105</span>),</span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="dt">type =</span> <span class="kw">c</span>(<span class="st">&quot;rare&quot;</span>, <span class="st">&quot;med_rare&quot;</span>, <span class="st">&quot;med_rare&quot;</span>, <span class="st">&quot;rare&quot;</span>))</span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a>steak_directions_for_apply =<span class="st"> </span><span class="cf">function</span>(temp_and_type) {</span>
<span id="cb20-6"><a href="#cb20-6"></a>    temp =<span class="st"> </span>temp_and_type[<span class="dv">1</span>]</span>
<span id="cb20-7"><a href="#cb20-7"></a>    steak_type =<span class="st"> </span>temp_and_type[<span class="dv">2</span>]</span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="cf">if</span>(steak_type <span class="op">==</span><span class="st"> &quot;rare&quot;</span> <span class="op">&amp;</span><span class="st"> </span>temp <span class="op">&gt;</span><span class="st"> </span><span class="dv">115</span>) {</span>
<span id="cb20-9"><a href="#cb20-9"></a>        <span class="kw">return</span>(<span class="st">&quot;take your steak off!&quot;</span>)</span>
<span id="cb20-10"><a href="#cb20-10"></a>    } <span class="cf">else</span> <span class="cf">if</span>(steak_type <span class="op">==</span><span class="st"> &quot;med_rare&quot;</span> <span class="op">&amp;</span><span class="st"> </span>temp <span class="op">&gt;</span><span class="st"> </span><span class="dv">125</span>) {</span>
<span id="cb20-11"><a href="#cb20-11"></a>        <span class="kw">return</span>(<span class="st">&quot;take your steak off!&quot;</span>)        </span>
<span id="cb20-12"><a href="#cb20-12"></a>    } </span>
<span id="cb20-13"><a href="#cb20-13"></a>    <span class="st">&quot;you can keep cooking&quot;</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>}</span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="co">## this works, but it really shouldn&#39;t</span></span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="kw">apply</span>(steak_combinations, <span class="dv">1</span>, steak_directions_for_apply)</span></code></pre></div>
<pre><code>## [1] &quot;take your steak off!&quot; &quot;you can keep cooking&quot; &quot;take your steak off!&quot;
## [4] &quot;you can keep cooking&quot;</code></pre>
</div>
</div>
<div class="slide section level2">

<p>One that <em>actually</em> doesn’t work:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>steak_admonishments_for_apply =<span class="st"> </span><span class="cf">function</span>(temp_and_type) {</span>
<span id="cb22-2"><a href="#cb22-2"></a>    temp =<span class="st"> </span>temp_and_type[<span class="dv">1</span>]</span>
<span id="cb22-3"><a href="#cb22-3"></a>    steak_type =<span class="st"> </span>temp_and_type[<span class="dv">2</span>]</span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="cf">if</span>(steak_type <span class="op">==</span><span class="st"> &quot;rare&quot;</span> <span class="op">&amp;</span><span class="st"> </span>temp <span class="op">&gt;</span><span class="st"> </span><span class="dv">115</span>) {</span>
<span id="cb22-5"><a href="#cb22-5"></a>        admonishment =<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;Your steak is overcooked by %f degrees!&quot;</span>, temp <span class="op">-</span><span class="st"> </span><span class="dv">115</span>)</span>
<span id="cb22-6"><a href="#cb22-6"></a>        <span class="kw">return</span>(admonhishment)</span>
<span id="cb22-7"><a href="#cb22-7"></a>    } <span class="cf">else</span> <span class="cf">if</span>(steak_type <span class="op">==</span><span class="st"> &quot;med_rare&quot;</span> <span class="op">&amp;</span><span class="st"> </span>temp <span class="op">&gt;</span><span class="st"> </span><span class="dv">125</span>) {</span>
<span id="cb22-8"><a href="#cb22-8"></a>        admonishment =<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;Your steak is overcooked by %f degrees!&quot;</span>, temp <span class="op">-</span><span class="st"> </span><span class="dv">125</span>)</span>
<span id="cb22-9"><a href="#cb22-9"></a>        <span class="kw">return</span>(admonishment)</span>
<span id="cb22-10"><a href="#cb22-10"></a>    }</span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="st">&quot;Your steak is not overcooked yet&quot;</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>}</span>
<span id="cb22-13"><a href="#cb22-13"></a><span class="kw">apply</span>(steak_combinations, <span class="dv">1</span>, steak_admonishments_for_apply)</span></code></pre></div>
<pre><code>## Error in temp - 115: non-numeric argument to binary operator</code></pre>
</div>
<div class="slide section level2">

<p>If you want to apply a function that uses columns of a data frame that are of different types, better/safer to use <code>mapply</code>:</p>
<p><code>mapply(FUN = f, vec1, vec2, ..., vecN)</code></p>
<ul class="incremental">
<li><p><code>f</code> is the function you want to apply</p></li>
<li><p>Output is a list, ith element will be <code>f(vec1[i], vec2[i], ..., vecN[i])</code></p></li>
</ul>
</div>
<div class="slide section level2">

<div class="incremental">
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a>steak_directions =<span class="st"> </span><span class="cf">function</span>(steak_temp, steak_type) {</span>
<span id="cb24-2"><a href="#cb24-2"></a>    <span class="cf">if</span>(steak_type <span class="op">==</span><span class="st"> &quot;rare&quot;</span> <span class="op">&amp;</span><span class="st"> </span>steak_temp <span class="op">&gt;</span><span class="st"> </span><span class="dv">115</span>) {</span>
<span id="cb24-3"><a href="#cb24-3"></a>        <span class="kw">return</span>(<span class="st">&quot;take your steak off!&quot;</span>)</span>
<span id="cb24-4"><a href="#cb24-4"></a>    } <span class="cf">else</span> <span class="cf">if</span>(steak_type <span class="op">==</span><span class="st"> &quot;med_rare&quot;</span> <span class="op">&amp;</span><span class="st"> </span>steak_temp <span class="op">&gt;</span><span class="st"> </span><span class="dv">125</span>) {</span>
<span id="cb24-5"><a href="#cb24-5"></a>        <span class="kw">return</span>(<span class="st">&quot;take your steak off!&quot;</span>)        </span>
<span id="cb24-6"><a href="#cb24-6"></a>    } </span>
<span id="cb24-7"><a href="#cb24-7"></a>    <span class="st">&quot;you can keep cooking&quot;</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>}</span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="kw">mapply</span>(<span class="dt">FUN =</span> steak_directions, steak_combinations<span class="op">$</span>temp, steak_combinations<span class="op">$</span>type)</span></code></pre></div>
<pre><code>## [1] &quot;take your steak off!&quot; &quot;you can keep cooking&quot; &quot;take your steak off!&quot;
## [4] &quot;you can keep cooking&quot;</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a>steak_admonishments =<span class="st"> </span><span class="cf">function</span>(steak_temp, steak_type) {</span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="cf">if</span>(steak_type <span class="op">==</span><span class="st"> &quot;rare&quot;</span> <span class="op">&amp;</span><span class="st"> </span>steak_temp <span class="op">&gt;</span><span class="st"> </span><span class="dv">115</span>) {</span>
<span id="cb26-3"><a href="#cb26-3"></a>        admonishment =<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;Your steak is overcooked by %i degrees!&quot;</span>, steak_temp <span class="op">-</span><span class="st"> </span><span class="dv">115</span>)</span>
<span id="cb26-4"><a href="#cb26-4"></a>        <span class="kw">return</span>(admonishment)</span>
<span id="cb26-5"><a href="#cb26-5"></a>    } <span class="cf">else</span> <span class="cf">if</span>(steak_type <span class="op">==</span><span class="st"> &quot;med_rare&quot;</span> <span class="op">&amp;</span><span class="st"> </span>steak_temp <span class="op">&gt;</span><span class="st"> </span><span class="dv">125</span>) {</span>
<span id="cb26-6"><a href="#cb26-6"></a>        admonishment =<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;Your steak is overcooked by %i degrees!&quot;</span>, steak_temp <span class="op">-</span><span class="st"> </span><span class="dv">125</span>)</span>
<span id="cb26-7"><a href="#cb26-7"></a>        <span class="kw">return</span>(admonishment)</span>
<span id="cb26-8"><a href="#cb26-8"></a>    }</span>
<span id="cb26-9"><a href="#cb26-9"></a>    <span class="st">&quot;Your steak is not overcooked yet.&quot;</span></span>
<span id="cb26-10"><a href="#cb26-10"></a>}</span>
<span id="cb26-11"><a href="#cb26-11"></a></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="kw">mapply</span>(<span class="dt">FUN =</span> steak_admonishments, steak_combinations<span class="op">$</span>temp, steak_combinations<span class="op">$</span>type)</span></code></pre></div>
<pre><code>## [1] &quot;Your steak is overcooked by 2 degrees!&quot; 
## [2] &quot;Your steak is not overcooked yet.&quot;      
## [3] &quot;Your steak is overcooked by 10 degrees!&quot;
## [4] &quot;Your steak is not overcooked yet.&quot;</code></pre>
</div>
</div>
<div id="what-if-things-arent-quite-so-tidy" class="slide section level2">
<h1>What if things aren’t quite so tidy?</h1>
<ul class="incremental">
<li><p>The <code>*apply</code> functions we’ve seen so far have applied a function element-by-element to a vector or matrix.</p></li>
<li><p>What if we need to apply a function not to individual elements/rows/columns, but to subsets of different sizes?</p></li>
</ul>
</div>
<div id="splitapplycombine-paradigm" class="slide section level2">
<h1>Split/apply/combine paradigm</h1>
<p>Turns out this is common enough that it has a name and a bunch of built-in functions.</p>
<p>The programming pattern is pretty clear from the name, what we want to do is:</p>
<ul class="incremental">
<li><p>split the data into groups</p></li>
<li><p>apply a function to each of the groups</p></li>
<li><p>combine the results of applying the function to each group into an output dataset</p></li>
</ul>
</div>
<div id="why-is-this-a-useful-abstraction" class="slide section level2">
<h1>Why is this a useful abstraction?</h1>
<p>Imagine how you would do this if you only had for-loops.</p>
<p>You would have to first</p>
<ul class="incremental">
<li><p>Compute what size the output dataset should be</p></li>
<li><p>Create a data structure to hold the output.</p></li>
</ul>
<p>Then, for each level of the grouping factor:</p>
<ul class="incremental">
<li><p>Compute how many data elements correspond to that grouping level</p></li>
<li><p>Create a data structure to hold the data subset</p></li>
<li><p>Loop through the data to extract the correct subset</p></li>
<li><p>Apply your function to that subset and put the output in the data structure your created at the beginning.</p></li>
</ul>
</div>
<div class="slide section level2">

<p>Compare with split/apply/combine abstraction:</p>
<ul class="incremental">
<li><p>Specify data</p></li>
<li><p>Specify grouping variable for split</p></li>
<li><p>Specify function to apply to each split</p></li>
</ul>
<p>The abstraction is useful both for writing and reading the resulting code: you think about <em>what</em> you want to do instead of <em>how</em> to do it.</p>
</div>
<div id="splitapplycombine-for-vectors" class="slide section level2">
<h1>Split/apply/combine for vectors</h1>
<p>Simple case: we have a vector, and a grouping factor, we want to apply a function to groups of elements of the vector defined by the grouping factor</p>
<p>Solution is tapply</p>
<p><code>tapply(X = x, INDEX = f, FUN = fun)</code></p>
<p>Syntax:</p>
<ul class="incremental">
<li><p><code>x</code>: A vector with the data.</p></li>
<li><p><code>f</code>: A factor variable describing how the data should be split up.</p></li>
<li><p><code>fun</code>: The function you want to apply to each subset of the data.</p></li>
</ul>
</div>
<div class="slide section level2">

<p>Example: data on police stops in New York City in 1998–1999, information on the number of stops as categorized by certain variables.</p>
<p>In particular, we have counts of police stops for all combinations of</p>
<ul class="incremental">
<li><p>precinct: 75 total</p></li>
<li><p>eth: Ethnicity of the person stopped, three possibilities, and</p></li>
<li><p>crime: The type of crime, four possibilities</p></li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a>frisk =</span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="st">    </span><span class="kw">read.table</span>(<span class="st">&quot;http://www.stat.columbia.edu/~gelman/arm/examples/police/frisk_with_noise.dat&quot;</span>,</span>
<span id="cb28-3"><a href="#cb28-3"></a>               <span class="dt">skip =</span> <span class="dv">6</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="kw">head</span>(frisk)</span></code></pre></div>
<pre><code>##   stops  pop past.arrests precinct eth crime
## 1    75 1720          191        1   1     1
## 2    36 1720           57        1   1     2
## 3    74 1720          599        1   1     3
## 4    17 1720          133        1   1     4
## 5    37 1368           62        1   2     1
## 6    39 1368           27        1   2     2</code></pre>
</div>
<div class="slide section level2">

<p>Suppose we want to get the total number of stops in each precinct.</p>
<p>We can use <code>tapply</code> with the <code>sum</code> function to do so:</p>
<div class="incremental">
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">tapply</span>(<span class="dt">X =</span> frisk<span class="op">$</span>stops, <span class="dt">INDEX =</span> frisk<span class="op">$</span>precinct, <span class="dt">FUN =</span> sum)</span></code></pre></div>
<pre><code>##    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 
##  385  347 1603 1411 1600 1297  649 1572  285 1156  838  884 2215 1165 2373  965 
##   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32 
##  946 2359 1311 1566 1613 4030 2334 2622 3685 1541 2005  902 2888 2157 1805 1041 
##   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48 
## 2966 2810  724 1189  997 1808 2464  859 1979 2679 1645 1669 2953 3443 1001 1574 
##   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64 
## 1041 3054 1208 2116 1216  995 1140  572  856 2671 1147 2941 1625 1635 1248 1351 
##   65   66   67   68   69   70   71   72   73   74   75 
## 2290 2941 2430 1109 1267 2476 2922 3560 3650 1327  322</code></pre>
<p>Just as a check, make sure that the numbers match up:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a>precinct_<span class="dv">1</span> =<span class="st"> </span><span class="kw">subset</span>(frisk, precinct <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="kw">sum</span>(precinct_<span class="dv">1</span><span class="op">$</span>stops)</span></code></pre></div>
<pre><code>## [1] 385</code></pre>
</div>
</div>
<div class="slide section level2">

<p>And remember how much better this is than iterating using a for loop would have been:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="co">## find the number of precincts and make a vector of the right length to store the output</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>precincts =<span class="st"> </span><span class="kw">unique</span>(frisk<span class="op">$</span>precinct)</span>
<span id="cb34-3"><a href="#cb34-3"></a>stops_per_precinct =<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(precincts))</span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="co">## iterate over precinct, get the subset for each one, compute the number of stops, and store</span></span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(precincts)) {</span>
<span id="cb34-6"><a href="#cb34-6"></a>    precinct_subset =<span class="st"> </span><span class="kw">subset</span>(frisk, precinct <span class="op">==</span><span class="st"> </span>precincts[i])</span>
<span id="cb34-7"><a href="#cb34-7"></a>    precinct_stops =<span class="st"> </span><span class="kw">sum</span>(precinct_subset<span class="op">$</span>stops)</span>
<span id="cb34-8"><a href="#cb34-8"></a>    stops_per_precinct[i] =<span class="st"> </span>precinct_stops</span>
<span id="cb34-9"><a href="#cb34-9"></a>}</span>
<span id="cb34-10"><a href="#cb34-10"></a>stops_per_precinct</span></code></pre></div>
<pre><code>##  [1]  385  347 1603 1411 1600 1297  649 1572  285 1156  838  884 2215 1165 2373
## [16]  965  946 2359 1311 1566 1613 4030 2334 2622 3685 1541 2005  902 2888 2157
## [31] 1805 1041 2966 2810  724 1189  997 1808 2464  859 1979 2679 1645 1669 2953
## [46] 3443 1001 1574 1041 3054 1208 2116 1216  995 1140  572  856 2671 1147 2941
## [61] 1625 1635 1248 1351 2290 2941 2430 1109 1267 2476 2922 3560 3650 1327  322</code></pre>
</div>
<div id="splitapplycombine-for-data-frames" class="slide section level2">
<h1>Split/apply/combine for data frames</h1>
<p>Splitting a data frame into groups of rows and applying a function to the groups:</p>
<p><code>by(data = df, INDICES = fact, FUN = fun)</code></p>
<ul class="incremental">
<li><p><code>df</code>: A data frame containing the data you want to split up and apply a function to.</p></li>
<li><p><code>fact</code>: A factor variable describing the groups you want to split <code>df</code> into.</p></li>
<li><p><code>fun</code>: The function you want to apply to each group. It should take as its first argument a data frame.</p></li>
</ul>
</div>
<div class="slide section level2">

<div class="incremental">
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a>stops_and_past_arrests_correlation =<span class="st"> </span><span class="cf">function</span>(frisk_subset) {</span>
<span id="cb36-2"><a href="#cb36-2"></a>    <span class="kw">cor</span>(frisk_subset<span class="op">$</span>stops, frisk_subset<span class="op">$</span>past.arrests)</span>
<span id="cb36-3"><a href="#cb36-3"></a>}</span>
<span id="cb36-4"><a href="#cb36-4"></a>within_precinct_cors =<span class="st"> </span><span class="kw">by</span>(frisk, frisk<span class="op">$</span>precinct, stops_and_past_arrests_correlation)</span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="kw">head</span>(within_precinct_cors)</span></code></pre></div>
<pre><code>## frisk$precinct
##           1           2           3           4           5           6 
##  0.60479730  0.01659348 -0.21949242  0.12046523 -0.06892661  0.54151306</code></pre>
</div>
</div>
<div id="anonymous-functions" class="slide section level2">
<h1>Anonymous functions</h1>
<div class="incremental">
<p>Here we only need the <code>stops_and_past_arrests_correlation</code> function in the context of <code>by</code>, so there’s no need to define it in the global environment.</p>
<p>Instead we can specify it as an anonymous function:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a>within_precinct_cors =<span class="st"> </span><span class="kw">by</span>(frisk, frisk<span class="op">$</span>precinct, <span class="cf">function</span>(frisk_subset) {</span>
<span id="cb38-2"><a href="#cb38-2"></a>    <span class="kw">cor</span>(frisk_subset<span class="op">$</span>stops, frisk_subset<span class="op">$</span>past.arrests)</span>
<span id="cb38-3"><a href="#cb38-3"></a>})</span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="kw">head</span>(within_precinct_cors)</span></code></pre></div>
<pre><code>## frisk$precinct
##           1           2           3           4           5           6 
##  0.60479730  0.01659348 -0.21949242  0.12046523 -0.06892661  0.54151306</code></pre>
</div>
</div>
<div class="slide section level2">

<p>A more complex example:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">data</span>(diamonds)</span>
<span id="cb40-2"><a href="#cb40-2"></a>get_diamond_coefficients =<span class="st"> </span><span class="cf">function</span>(data_subset) {</span>
<span id="cb40-3"><a href="#cb40-3"></a>    diamond_lm =<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(price) <span class="op">~</span><span class="st"> </span>carat, <span class="dt">data =</span> data_subset)</span>
<span id="cb40-4"><a href="#cb40-4"></a>    diamond_coefficients =<span class="st"> </span><span class="kw">coef</span>(diamond_lm)</span>
<span id="cb40-5"><a href="#cb40-5"></a>    <span class="kw">return</span>(diamond_coefficients)</span>
<span id="cb40-6"><a href="#cb40-6"></a>}</span>
<span id="cb40-7"><a href="#cb40-7"></a><span class="co">## by does the split and apply steps, and an ugly version of a combine step</span></span>
<span id="cb40-8"><a href="#cb40-8"></a>out =<span class="st"> </span><span class="kw">by</span>(diamonds, diamonds<span class="op">$</span>color, get_diamond_coefficients)</span></code></pre></div>
</div>
<div class="slide section level2">

<p>The output is as a list with some extra attributes (the class is <code>by</code>, as you can check).</p>
<p>The form is not ideal on its own, usually you’ll want to simplify it. You have a couple of options, including the examples below:</p>
<div class="incremental">
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">simplify2array</span>(out)</span></code></pre></div>
<pre><code>##                    D        E        F        G        H        I        J
## (Intercept) 6.048811 6.034513 6.088442 6.109554 6.180284 6.175315 6.254074
## carat       2.383864 2.348335 2.272790 2.178489 1.906300 1.799199 1.627947</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a><span class="co">## changing the output from a list to a matrix</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="kw">do.call</span>(rbind, out)</span></code></pre></div>
<pre><code>##   (Intercept)    carat
## D    6.048811 2.383864
## E    6.034513 2.348335
## F    6.088442 2.272790
## G    6.109554 2.178489
## H    6.180284 1.906300
## I    6.175315 1.799199
## J    6.254074 1.627947</code></pre>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a><span class="co">## it&#39;s kind of bad that the splitting variable is only available as row names</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="co">## we can fix that but it&#39;s a bit of a pain</span></span>
<span id="cb45-3"><a href="#cb45-3"></a>diamond_coef_matrix =<span class="st"> </span><span class="kw">do.call</span>(rbind, out)</span>
<span id="cb45-4"><a href="#cb45-4"></a>diamond_coef_df =<span class="st"> </span><span class="kw">data.frame</span>(diamond_coef_matrix,</span>
<span id="cb45-5"><a href="#cb45-5"></a>    <span class="dt">color =</span> <span class="kw">attributes</span>(out)<span class="op">$</span>dimnames<span class="op">$</span><span class="st">`</span><span class="dt">diamonds$color</span><span class="st">`</span>)</span>
<span id="cb45-6"><a href="#cb45-6"></a>diamond_coef_df</span></code></pre></div>
<pre><code>##   X.Intercept.    carat color
## D     6.048811 2.383864     D
## E     6.034513 2.348335     E
## F     6.088442 2.272790     F
## G     6.109554 2.178489     G
## H     6.180284 1.906300     H
## I     6.175315 1.799199     I
## J     6.254074 1.627947     J</code></pre>
</div>
</div>
<div class="slide section level2">

<p><code>by</code> can also be used with multiple grouping factors:</p>
<div class="incremental">
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">by</span>(diamonds, diamonds[, <span class="kw">c</span>(<span class="st">&quot;color&quot;</span>, <span class="st">&quot;cut&quot;</span>)], get_diamond_coefficients)</span></code></pre></div>
<pre><code>## color: D
## cut: Fair
## (Intercept)       carat 
##    6.723804    1.514938 
## ------------------------------------------------------------ 
## color: E
## cut: Fair
## (Intercept)       carat 
##    6.246003    1.955816 
## ------------------------------------------------------------ 
## color: F
## cut: Fair
## (Intercept)       carat 
##    6.466073    1.637304 
## ------------------------------------------------------------ 
## color: G
## cut: Fair
## (Intercept)       carat 
##    6.659407    1.358722 
## ------------------------------------------------------------ 
## color: H
## cut: Fair
## (Intercept)       carat 
##    6.921231    1.122101 
## ------------------------------------------------------------ 
## color: I
## cut: Fair
## (Intercept)       carat 
##    6.759325    1.202279 
## ------------------------------------------------------------ 
## color: J
## cut: Fair
## (Intercept)       carat 
##   7.0504140   0.8761416 
## ------------------------------------------------------------ 
## color: D
## cut: Good
## (Intercept)       carat 
##    5.925962    2.415309 
## ------------------------------------------------------------ 
## color: E
## cut: Good
## (Intercept)       carat 
##    5.976449    2.322896 
## ------------------------------------------------------------ 
## color: F
## cut: Good
## (Intercept)       carat 
##    6.016284    2.273226 
## ------------------------------------------------------------ 
## color: G
## cut: Good
## (Intercept)       carat 
##    6.180670    2.037179 
## ------------------------------------------------------------ 
## color: H
## cut: Good
## (Intercept)       carat 
##    6.106822    1.952841 
## ------------------------------------------------------------ 
## color: I
## cut: Good
## (Intercept)       carat 
##    6.182043    1.762664 
## ------------------------------------------------------------ 
## color: J
## cut: Good
## (Intercept)       carat 
##    6.133176    1.728532 
## ------------------------------------------------------------ 
## color: D
## cut: Very Good
## (Intercept)       carat 
##    5.953898    2.487391 
## ------------------------------------------------------------ 
## color: E
## cut: Very Good
## (Intercept)       carat 
##    5.909810    2.480529 
## ------------------------------------------------------------ 
## color: F
## cut: Very Good
## (Intercept)       carat 
##    5.947350    2.446917 
## ------------------------------------------------------------ 
## color: G
## cut: Very Good
## (Intercept)       carat 
##    5.965330    2.343517 
## ------------------------------------------------------------ 
## color: H
## cut: Very Good
## (Intercept)       carat 
##    6.110954    1.993643 
## ------------------------------------------------------------ 
## color: I
## cut: Very Good
## (Intercept)       carat 
##    6.207955    1.807934 
## ------------------------------------------------------------ 
## color: J
## cut: Very Good
## (Intercept)       carat 
##    6.211086    1.696800 
## ------------------------------------------------------------ 
## color: D
## cut: Premium
## (Intercept)       carat 
##    6.109571    2.258907 
## ------------------------------------------------------------ 
## color: E
## cut: Premium
## (Intercept)       carat 
##    6.133275    2.185096 
## ------------------------------------------------------------ 
## color: F
## cut: Premium
## (Intercept)       carat 
##    6.189666    2.124037 
## ------------------------------------------------------------ 
## color: G
## cut: Premium
## (Intercept)       carat 
##    6.181514    2.052932 
## ------------------------------------------------------------ 
## color: H
## cut: Premium
## (Intercept)       carat 
##    6.270586    1.809367 
## ------------------------------------------------------------ 
## color: I
## cut: Premium
## (Intercept)       carat 
##    6.229239    1.723257 
## ------------------------------------------------------------ 
## color: J
## cut: Premium
## (Intercept)       carat 
##    6.305114    1.578440 
## ------------------------------------------------------------ 
## color: D
## cut: Ideal
## (Intercept)       carat 
##    5.970971    2.626088 
## ------------------------------------------------------------ 
## color: E
## cut: Ideal
## (Intercept)       carat 
##    5.989833    2.526368 
## ------------------------------------------------------------ 
## color: F
## cut: Ideal
## (Intercept)       carat 
##    6.052536    2.408753 
## ------------------------------------------------------------ 
## color: G
## cut: Ideal
## (Intercept)       carat 
##    6.032829    2.367710 
## ------------------------------------------------------------ 
## color: H
## cut: Ideal
## (Intercept)       carat 
##    6.075676    2.071994 
## ------------------------------------------------------------ 
## color: I
## cut: Ideal
## (Intercept)       carat 
##    6.071246    1.932255 
## ------------------------------------------------------------ 
## color: J
## cut: Ideal
## (Intercept)       carat 
##    6.104631    1.784315</code></pre>
<p>But how do you get at which coefficients correspond to which factor groups?</p>
</div>
</div>
<div id="if-you-want-to-do-split-and-applycombine-separately" class="slide section level2">
<h1>If you want to do split and apply/combine separately</h1>
<p><code>split</code> does just the splitting part of split/apply/combine</p>
<p>Syntax: <code>split(x, f)</code></p>
<ul class="incremental">
<li><p><code>x</code>: Your data, either a vector or a data frame, that you want to divide into groups.</p></li>
<li><p><code>f</code>: A factor variable used to split <code>x</code>. Length is equal to the length of <code>x</code> if it is a vector or equal to the number of rows of <code>x</code> if it is a data frame.</p></li>
</ul>
<p>Output:</p>
<ul class="incremental">
<li><p>A list of length equal to the number of levels in <code>f</code></p></li>
<li><p>Each element of the list is either a vector or a data frame, depending on what <code>x</code> was, containing the elements of <code>x</code> corresponding to one of the levels of <code>f</code>.</p></li>
</ul>
</div>
<div class="slide section level2">

<p>We can re-do the stop-and-frisk example that we used <code>tapply</code> for with <code>split</code> followed by <code>lapply</code> or <code>sapply</code></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a>frisk_split_by_precinct =<span class="st"> </span><span class="kw">split</span>(frisk<span class="op">$</span>stops, frisk<span class="op">$</span>precinct)</span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="co">## check that this has length 75, the number of precincts</span></span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="kw">length</span>(frisk_split_by_precinct)</span></code></pre></div>
<pre><code>## [1] 75</code></pre>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">sapply</span>(frisk_split_by_precinct, sum)</span></code></pre></div>
<pre><code>##    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 
##  385  347 1603 1411 1600 1297  649 1572  285 1156  838  884 2215 1165 2373  965 
##   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32 
##  946 2359 1311 1566 1613 4030 2334 2622 3685 1541 2005  902 2888 2157 1805 1041 
##   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48 
## 2966 2810  724 1189  997 1808 2464  859 1979 2679 1645 1669 2953 3443 1001 1574 
##   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64 
## 1041 3054 1208 2116 1216  995 1140  572  856 2671 1147 2941 1625 1635 1248 1351 
##   65   66   67   68   69   70   71   72   73   74   75 
## 2290 2941 2430 1109 1267 2476 2922 3560 3650 1327  322</code></pre>
</div>
<div class="slide section level2">

<p>In general, base R apply-family functions don’t produce nice output from the combine step.</p>
<p>We’ll see implementations of split/apply/combine next time that do a nicer job.</p>
</div>
</body>
</html>
